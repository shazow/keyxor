package soze

import (
	"crypto/rand"
	"errors"
	"io"
)

// TODO: use io.ReadFull instead of checking read lengths?

var bufSize = 1024 * 8

// Split takes an input key reader and N output writers. It splits the input
// key into N key components which need to be XOR'd together in order to
// produce the original input key. Split uses crypto/rand.Reader as the
// randomness source.
func Split(in io.Reader, outs []io.Writer) error {
	return splitWithRand(in, outs, rand.Reader)
}

func splitWithRand(in io.Reader, outs []io.Writer, randReader io.Reader) error {
	if len(outs) < 2 {
		return errors.New("must have at least two outputs")
	}

	done := false
	inBuf, randBuf, combinedBuf := make([]byte, bufSize), make([]byte, bufSize), make([]byte, bufSize)
	for !done {
		n, err := in.Read(inBuf)
		if err == io.EOF {
			done = true
		} else if err != nil {
			return err
		}
		if n == 0 {
			continue
		}

		// Accumulate the random key components for N-1 keys
		for i, out := range outs {
			if i == 0 {
				// First index contains the combined material, for convenience
				continue
			}
			nRand, err := randReader.Read(randBuf[:n])
			if err != nil {
				return err
			}
			if nRand < n {
				return ErrSizeMismatch{"insufficient random data", nRand, n}
			}

			xorInto(combinedBuf[:n], randBuf[:n])

			// Write the random key component
			nOut, err := out.Write(randBuf[:n])
			if err != nil {
				return err
			}
			if nOut != n {
				return ErrSizeMismatch{"written output", nOut, n}
			}
		}

		// Write the combined key component
		xorInto(combinedBuf[:n], inBuf[:n])

		// Write the combined material into the Nth key (first index in this case)
		nOut, err := outs[0].Write(combinedBuf[:n])
		if err != nil {
			return err
		}
		if nOut != n {
			return ErrSizeMismatch{"written output", nOut, n}
		}
		zero(combinedBuf[:n])
	}
	return nil
}

// Merge takes an output key writer and N input key component readers, and
// applies XOR to the inputs to produce the original key. The key components
// are like ones generated by Split. Inputs will be truncated to the shortest
// input.
func Merge(out io.Writer, ins []io.Reader) error {
	inBuf, outBuf := make([]byte, bufSize), make([]byte, bufSize)
	done := false
	for !done {
		var n, expected int
		var err error
		for i, in := range ins {
			n, err = in.Read(inBuf)
			if err == io.EOF {
				done = true
			} else if err != nil {
				return err
			}
			if i == 0 {
				expected = n
			} else if n != expected {
				return ErrSizeMismatch{"read input", n, expected}
			} else if n == 0 {
				continue
			}
			xorInto(outBuf[:n], inBuf[:n])
		}
		if n == 0 && !done {
			return ErrSizeMismatch{Message: "input"}
		}

		nOut, err := out.Write(outBuf[:n])
		if err != nil {
			return err
		}
		if nOut != n {
			return ErrSizeMismatch{"written output", nOut, n}
		}
		zero(outBuf[:n])
	}
	return nil
}
